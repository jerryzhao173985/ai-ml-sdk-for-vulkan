/*
 * SPDX-FileCopyrightText: Copyright 2023-2024 Arm Limited and/or its affiliates <open-source-office@arm.com>
 * SPDX-License-Identifier: Apache-2.0
 */

#define IN_OUT_T %in_out_t%

layout(local_size_x = %warpX%) in;

layout(constant_id = 0) const uint32_t RANK = RANK_MAX;

layout(set = 0, binding = 0) uniform tensorARM<IN_OUT_T, RANK> outputData;
layout(set = 1, binding = 0) uniform tensorARM<uint8_t, RANK> inputData1;
layout(set = 2, binding = 0) uniform tensorARM<IN_OUT_T, RANK> inputData2;
layout(set = 3, binding = 0) uniform tensorARM<IN_OUT_T, RANK> inputData3;

void main() {
    uint[RANK] index;
    getIndex(outputData, index);

    uint[RANK] inputShape;
    uint[RANK] inputIndex;
    uint8_t value1;

    getShape(inputShape, inputData1);
    applyBroadcast(inputShape, index, inputIndex);
    tensorReadARM(inputData1, inputIndex, value1);

    IN_OUT_T result;

    if (value1 != 0) {
        getShape(inputShape, inputData2);
        applyBroadcast(inputShape, index, inputIndex);
        tensorReadARM(inputData2, inputIndex, result);
    } else {
        getShape(inputShape, inputData3);
        applyBroadcast(inputShape, index, inputIndex);
        tensorReadARM(inputData3, inputIndex, result);
    }

    tensorWriteARM(outputData, index, IN_OUT_T(result));
}
