/*
 * SPDX-FileCopyrightText: Copyright 2023-2025 Arm Limited and/or its affiliates <open-source-office@arm.com>
 * SPDX-License-Identifier: Apache-2.0
 */

#define IN_T %in_t%
#define OUT_T %out_t%
#define WEIGHT_T %weight_t%
#define TYPE_ACC %acc_t_type%
#define ACC_T %acc_t%

#if TYPE_ACC == TYPE_INT64
    #define VEC4 dvec4
#elif TYPE_ACC == TYPE_INT32
    #define VEC4 ivec4
#else
    #define VEC4 vec4
#endif

layout(local_size_x = %warpX%) in;

layout(push_constant) uniform PushConstants {
    int32_t inputZeroPoint;
    int32_t weightZeroPoint;
    int32_t pad[4];
    int32_t stride[2];
    int32_t dilation[2];
} pushConstants;

layout(set = 0, binding = 0) uniform tensorARM<OUT_T, 4> outputData;       // [N, OH, OW, C * M]
layout(set = 1, binding = 0) uniform tensorARM<IN_T, 4> inputData;         // [N, H, W, C]
layout(set = 2, binding = 0) uniform tensorARM<WEIGHT_T, 4> weightsData;   // [KH, KW, C, M]
layout(set = 3, binding = 0) uniform tensorARM<OUT_T, 1> biasesData;       // [BC]

void main() {
    uint[4] index;
    getIndex4(outputData, index);

    const uint n = index[0];
    const uint oy = index[1];
    const uint ox = index[2];
    const uint ocm = index[3];
    const uint c = ocm / tensorSizeARM(weightsData, 3);
    const uint m = ocm % tensorSizeARM(weightsData, 3);

    const uint iy = oy * pushConstants.stride[0] - pushConstants.pad[0];
    const uint ix = ox * pushConstants.stride[1] - pushConstants.pad[2];

    ACC_T acc = ACC_T(0);

    for (uint ky = 0; ky < tensorSizeARM(weightsData, 0); ky++) {
        for (uint kx = 0; kx < tensorSizeARM(weightsData, 1); kx++) {
            const uint y = iy + ky * pushConstants.dilation[0];
            const uint x = ix + kx * pushConstants.dilation[1];

            if (y < tensorSizeARM(inputData, 1) && x < tensorSizeARM(inputData, 2)) {
                IN_T tempValue;
                uint index[] = {n, y, x, c};
                tensorReadARM(inputData, index, tempValue);
                ACC_T value = ACC_T(tempValue);

                WEIGHT_T tempWeight;
                uint weightIndex[] = {ky, kx, c, m};
                tensorReadARM(weightsData, weightIndex, tempWeight);
                ACC_T weight = ACC_T(tempWeight);

                ACC_T outValue = ACC_T(value) - ACC_T(pushConstants.inputZeroPoint);
                ACC_T outWeight = ACC_T(weight) - ACC_T(pushConstants.weightZeroPoint);

                acc += outValue * outWeight;
            }
        }
    }

    OUT_T bias;
    tensorReadARM(biasesData, uint[](tensorSizeARM(biasesData, 0) == 1 ? 0 : ocm), bias);
    bias += OUT_T(acc);

    tensorWriteARM(outputData, index, bias);
}
