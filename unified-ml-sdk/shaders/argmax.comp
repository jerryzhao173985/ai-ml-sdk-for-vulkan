/*
 * SPDX-FileCopyrightText: Copyright 2023-2025 Arm Limited and/or its affiliates <open-source-office@arm.com>
 * SPDX-License-Identifier: Apache-2.0
 */

#define IN_T %in_t%
#define TYPE_IN %in_t_type%

layout(local_size_x = %warpX%) in;

layout(push_constant) uniform PushConstants {
    uint axis;
    uint nanMode;
} pushConstants;

layout(constant_id = 0) const uint32_t RANK_IN = RANK_MAX;
layout(constant_id = 1) const uint32_t RANK_OUT = RANK_MAX;

layout(set = 0, binding = 0) uniform tensorARM<int32_t, RANK_OUT> outputData;
layout(set = 1, binding = 0) uniform tensorARM<IN_T, RANK_IN> inputData;

void main() {
    uint[RANK_OUT] index;
    getIndex(outputData, index);

    uint[RANK_IN] inputIndex;
    for (uint i = 0; i < pushConstants.axis; i++) {
        inputIndex[i] = index[i];
    }

    for (uint i = pushConstants.axis; i < RANK_OUT; i++) {
        inputIndex[i + 1] = index[i];
    }

    IN_T maxValue = IN_T(%in_t_lowest%);
    int32_t maxIndex = 0;

    uint[RANK_IN] inputShape;
    getShape(inputShape, inputData);

    for (int32_t i = 0; i < inputShape[pushConstants.axis]; i++) {
        inputIndex[pushConstants.axis] = i;
        IN_T value;
        tensorReadARM(inputData, inputIndex, value);

        #if IS_FLOAT(TYPE_IN)
        if (isnan(value)) {
            if (pushConstants.nanMode == NAN_MODE_IGNORE) {
                continue;
            }
            maxIndex = i;
            break;
        }
        #endif

        if (value > maxValue) {
            maxValue = value;
            maxIndex = i;
        }
    }

    tensorWriteARM(outputData, index, maxIndex);
}
