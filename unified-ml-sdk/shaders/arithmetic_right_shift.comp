/*
 * SPDX-FileCopyrightText: Copyright 2023-2024 Arm Limited and/or its affiliates <open-source-office@arm.com>
 * SPDX-License-Identifier: Apache-2.0
 */

#define IN_OUT_T %in_out_t%

layout(local_size_x = %warpX%) in;

layout(push_constant) uniform PushConstants {
    uint round;
} pushConstants;

layout(constant_id = 0) const uint32_t RANK_IN = RANK_MAX;
layout(constant_id = 1) const uint32_t RANK_OUT = RANK_MAX;

layout(set = 0, binding = 0) uniform tensorARM<IN_OUT_T, RANK_OUT> outputData;
layout(set = 1, binding = 0) uniform tensorARM<IN_OUT_T, RANK_IN> inputData1;
layout(set = 2, binding = 0) uniform tensorARM<IN_OUT_T, RANK_IN> inputData2;

void main() {
    uint[RANK_OUT] index;
    getIndex(outputData, index);

    uint[RANK_IN] inputTensor1;
    getShape(inputTensor1, inputData1);
    uint[RANK_IN] inputTensor2;
    getShape(inputTensor2, inputData2);

    uint[RANK_IN] coords1;
    applyBroadcast(inputTensor1, index, coords1);
    uint[RANK_IN] coords2;
    applyBroadcast(inputTensor2, index, coords2);

    IN_OUT_T value1;
    tensorReadARM(inputData1, coords1, value1);
    IN_OUT_T value2;
    tensorReadARM(inputData2, coords2, value2);

    IN_OUT_T result = value1 >> value2;

    const bool round = pushConstants.round != 0;
    if (round && value2 > 0) {
        if (((value1 >> IN_OUT_T(value2 - 1)) & 1) != 0) {
            result++;
        }
    }
    tensorWriteARM(outputData, index, result);
}
