/*
 * SPDX-FileCopyrightText: Copyright 2023-2025 Arm Limited and/or its affiliates <open-source-office@arm.com>
 * SPDX-License-Identifier: Apache-2.0
 */

#define IN_T %in_t%
#define MUL_T %mul_t%
#define OUT_T %out_t%

layout(local_size_x = %warpX%) in;

layout(push_constant) uniform PushConstants {
    int32_t inputZeroPoint;
    int32_t outputZeroPoint;
} pushConstants;

layout(constant_id = 0) const uint32_t RANK = RANK_MAX;
layout(constant_id = 1) const uint32_t SCALE32 = 0;
layout(constant_id = 2) const uint32_t DOUBLE_ROUND = 0;
layout(constant_id = 3) const uint32_t PER_CHANNEL = 0;

layout(set = 0, binding = 0) uniform tensorARM<OUT_T, RANK> outputData;
layout(set = 1, binding = 0) uniform tensorARM<IN_T, RANK> inputData;
layout(set = 2, binding = 0) uniform tensorARM<MUL_T, 1> multiplier;
layout(set = 3, binding = 0) uniform tensorARM<int8_t, 1> shiftData;

int32_t applyScale(int64_t value, int32_t multiplier, int8_t shift, bool doubleRound) {
    int64_t round = int64_t(1) << (shift - 1);

    if (doubleRound) {
        if (shift > 31) {
            if (value >= 0) {
                round += 1 << 30;
            }
            else {
                round -= 1 << 30;
            }
        }
    }

    int64_t result = value * multiplier;
    result += round;
    result >>= shift;

    return int32_t(result);
}

void main() {
    uint[RANK] index;
    getIndex(outputData, index);

    const bool scale32 = SCALE32 != 0;
    const bool doubleRound = DOUBLE_ROUND != 0;
    const bool perChannel = PER_CHANNEL != 0;
    const uint c = perChannel ? index[RANK - 1] : uint(0);

    IN_T val;
    tensorReadARM(inputData, index, val);
    int64_t value = int64_t(val) - int64_t(IN_T(pushConstants.inputZeroPoint));

    MUL_T mulVal;
    tensorReadARM(multiplier, uint[1](c), mulVal);

    int8_t shiftVal;
    tensorReadARM(shiftData, uint[1](c), shiftVal);

    int32_t result = applyScale(value, int32_t(mulVal), shiftVal, scale32 && doubleRound);
    result += OUT_T(pushConstants.outputZeroPoint);
    result = int32_t(clamp(result, OUT_T(%out_t_lowest%), OUT_T(%out_t_max%)));

    tensorWriteARM(outputData, index, OUT_T(result));
}
