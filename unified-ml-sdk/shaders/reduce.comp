/*
 * SPDX-FileCopyrightText: Copyright 2023-2025 Arm Limited and/or its affiliates <open-source-office@arm.com>
 * SPDX-License-Identifier: Apache-2.0
 */

#define IN_OUT_T %in_out_t%
#define TYPE_IN_OUT %in_out_t_type%

layout(local_size_x = %warpX%) in;

layout(push_constant) uniform PushConstants {
    uint axis;
    uint nanMode;
} pushConstants;

layout(constant_id = 0) const uint32_t RANK = RANK_MAX;

layout(set = 0, binding = 0) uniform tensorARM<IN_OUT_T, RANK> outputData;
layout(set = 1, binding = 0) uniform tensorARM<IN_OUT_T, RANK> inputData;

void main() {
    uint[RANK] index;
    getIndex(outputData, index);

    const uint dim = index[pushConstants.axis];

    IN_OUT_T result = IN_OUT_T(%init%);

    uint[RANK] inputShape;
    getShape(inputShape, inputData);

    for (uint i = 0; i < inputShape[pushConstants.axis]; i++) {
        index[pushConstants.axis] = i;
        IN_OUT_T value;
        tensorReadARM(inputData, index, value);

#if IS_FLOAT(TYPE_IN_OUT)
        if (isnan(value)) {
            if (pushConstants.nanMode == NAN_MODE_IGNORE) {
                // Ignore value and continue
                continue;
            }
            if (pushConstants.nanMode == NAN_MODE_PROPAGATE) {
                // If any value is NaN, then the result must be NaN
                result = value;
                break;
            }
        }
#endif

        result = IN_OUT_T(%operation%);
    }

    index[pushConstants.axis] = dim;
    tensorWriteARM(outputData, index, result);
}
