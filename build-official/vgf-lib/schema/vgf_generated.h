// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_VGF_VGF_H_
#define FLATBUFFERS_GENERATED_VGF_VGF_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace VGF {

struct SPIRV;
struct SPIRVBuilder;

struct Module;
struct ModuleBuilder;

struct ModuleTable;
struct ModuleTableBuilder;

struct Description;
struct DescriptionBuilder;

struct ModelResourceTableEntry;
struct ModelResourceTableEntryBuilder;

struct ModelResourceTable;
struct ModelResourceTableBuilder;

struct BindingSlot;
struct BindingSlotBuilder;

struct DescriptorSetInfo;
struct DescriptorSetInfoBuilder;

struct PushConstantRange;
struct PushConstantRangeBuilder;

struct SegmentInfo;
struct SegmentInfoBuilder;

struct ModelSequenceTable;
struct ModelSequenceTableBuilder;

struct ConstantData;
struct ConstantDataBuilder;

struct ConstantSection;
struct ConstantSectionBuilder;

enum ModuleCode : uint8_t {
  ModuleCode_NONE = 0,
  ModuleCode_SPIRV = 1,
  ModuleCode_MIN = ModuleCode_NONE,
  ModuleCode_MAX = ModuleCode_SPIRV
};

inline const ModuleCode (&EnumValuesModuleCode())[2] {
  static const ModuleCode values[] = {
    ModuleCode_NONE,
    ModuleCode_SPIRV
  };
  return values;
}

inline const char * const *EnumNamesModuleCode() {
  static const char * const names[3] = {
    "NONE",
    "SPIRV",
    nullptr
  };
  return names;
}

inline const char *EnumNameModuleCode(ModuleCode e) {
  if (::flatbuffers::IsOutRange(e, ModuleCode_NONE, ModuleCode_SPIRV)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesModuleCode()[index];
}

template<typename T> struct ModuleCodeTraits {
  static const ModuleCode enum_value = ModuleCode_NONE;
};

template<> struct ModuleCodeTraits<VGF::SPIRV> {
  static const ModuleCode enum_value = ModuleCode_SPIRV;
};

bool VerifyModuleCode(::flatbuffers::Verifier &verifier, const void *obj, ModuleCode type);
bool VerifyModuleCodeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum ModuleType : uint8_t {
  ModuleType_COMPUTE = 0,
  ModuleType_GRAPH = 1,
  ModuleType_MIN = ModuleType_COMPUTE,
  ModuleType_MAX = ModuleType_GRAPH
};

inline const ModuleType (&EnumValuesModuleType())[2] {
  static const ModuleType values[] = {
    ModuleType_COMPUTE,
    ModuleType_GRAPH
  };
  return values;
}

inline const char * const *EnumNamesModuleType() {
  static const char * const names[3] = {
    "COMPUTE",
    "GRAPH",
    nullptr
  };
  return names;
}

inline const char *EnumNameModuleType(ModuleType e) {
  if (::flatbuffers::IsOutRange(e, ModuleType_COMPUTE, ModuleType_GRAPH)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesModuleType()[index];
}

enum ResourceCategory : uint8_t {
  ResourceCategory_INPUT = 0,
  ResourceCategory_OUTPUT = 1,
  ResourceCategory_INTERMEDIATE = 2,
  ResourceCategory_CONSTANT = 3,
  ResourceCategory_MIN = ResourceCategory_INPUT,
  ResourceCategory_MAX = ResourceCategory_CONSTANT
};

inline const ResourceCategory (&EnumValuesResourceCategory())[4] {
  static const ResourceCategory values[] = {
    ResourceCategory_INPUT,
    ResourceCategory_OUTPUT,
    ResourceCategory_INTERMEDIATE,
    ResourceCategory_CONSTANT
  };
  return values;
}

inline const char * const *EnumNamesResourceCategory() {
  static const char * const names[5] = {
    "INPUT",
    "OUTPUT",
    "INTERMEDIATE",
    "CONSTANT",
    nullptr
  };
  return names;
}

inline const char *EnumNameResourceCategory(ResourceCategory e) {
  if (::flatbuffers::IsOutRange(e, ResourceCategory_INPUT, ResourceCategory_CONSTANT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResourceCategory()[index];
}

struct SPIRV FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SPIRVBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WORDS = 4
  };
  const ::flatbuffers::Vector<uint32_t> *words() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_WORDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WORDS) &&
           verifier.VerifyVector(words()) &&
           verifier.EndTable();
  }
};

struct SPIRVBuilder {
  typedef SPIRV Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_words(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> words) {
    fbb_.AddOffset(SPIRV::VT_WORDS, words);
  }
  explicit SPIRVBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SPIRV> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SPIRV>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SPIRV> CreateSPIRV(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> words = 0) {
  SPIRVBuilder builder_(_fbb);
  builder_.add_words(words);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SPIRV> CreateSPIRVDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *words = nullptr) {
  auto words__ = words ? _fbb.CreateVector<uint32_t>(*words) : 0;
  return VGF::CreateSPIRV(
      _fbb,
      words__);
}

struct Module FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ModuleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_NAME = 6,
    VT_ENTRY_POINT = 8,
    VT_CODE_TYPE = 10,
    VT_CODE = 12
  };
  VGF::ModuleType type() const {
    return static_cast<VGF::ModuleType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *entry_point() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ENTRY_POINT);
  }
  VGF::ModuleCode code_type() const {
    return static_cast<VGF::ModuleCode>(GetField<uint8_t>(VT_CODE_TYPE, 0));
  }
  const void *code() const {
    return GetPointer<const void *>(VT_CODE);
  }
  template<typename T> const T *code_as() const;
  const VGF::SPIRV *code_as_SPIRV() const {
    return code_type() == VGF::ModuleCode_SPIRV ? static_cast<const VGF::SPIRV *>(code()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_ENTRY_POINT) &&
           verifier.VerifyString(entry_point()) &&
           VerifyField<uint8_t>(verifier, VT_CODE_TYPE, 1) &&
           VerifyOffset(verifier, VT_CODE) &&
           VerifyModuleCode(verifier, code(), code_type()) &&
           verifier.EndTable();
  }
};

template<> inline const VGF::SPIRV *Module::code_as<VGF::SPIRV>() const {
  return code_as_SPIRV();
}

struct ModuleBuilder {
  typedef Module Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(VGF::ModuleType type) {
    fbb_.AddElement<uint8_t>(Module::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Module::VT_NAME, name);
  }
  void add_entry_point(::flatbuffers::Offset<::flatbuffers::String> entry_point) {
    fbb_.AddOffset(Module::VT_ENTRY_POINT, entry_point);
  }
  void add_code_type(VGF::ModuleCode code_type) {
    fbb_.AddElement<uint8_t>(Module::VT_CODE_TYPE, static_cast<uint8_t>(code_type), 0);
  }
  void add_code(::flatbuffers::Offset<void> code) {
    fbb_.AddOffset(Module::VT_CODE, code);
  }
  explicit ModuleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Module> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Module>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Module> CreateModule(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    VGF::ModuleType type = VGF::ModuleType_COMPUTE,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> entry_point = 0,
    VGF::ModuleCode code_type = VGF::ModuleCode_NONE,
    ::flatbuffers::Offset<void> code = 0) {
  ModuleBuilder builder_(_fbb);
  builder_.add_code(code);
  builder_.add_entry_point(entry_point);
  builder_.add_name(name);
  builder_.add_code_type(code_type);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Module> CreateModuleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    VGF::ModuleType type = VGF::ModuleType_COMPUTE,
    const char *name = nullptr,
    const char *entry_point = nullptr,
    VGF::ModuleCode code_type = VGF::ModuleCode_NONE,
    ::flatbuffers::Offset<void> code = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto entry_point__ = entry_point ? _fbb.CreateString(entry_point) : 0;
  return VGF::CreateModule(
      _fbb,
      type,
      name__,
      entry_point__,
      code_type,
      code);
}

struct ModuleTable FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ModuleTableBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODULES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<VGF::Module>> *modules() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<VGF::Module>> *>(VT_MODULES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MODULES) &&
           verifier.VerifyVector(modules()) &&
           verifier.VerifyVectorOfTables(modules()) &&
           verifier.EndTable();
  }
};

struct ModuleTableBuilder {
  typedef ModuleTable Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_modules(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VGF::Module>>> modules) {
    fbb_.AddOffset(ModuleTable::VT_MODULES, modules);
  }
  explicit ModuleTableBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ModuleTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ModuleTable>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ModuleTable> CreateModuleTable(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VGF::Module>>> modules = 0) {
  ModuleTableBuilder builder_(_fbb);
  builder_.add_modules(modules);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ModuleTable> CreateModuleTableDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<VGF::Module>> *modules = nullptr) {
  auto modules__ = modules ? _fbb.CreateVector<::flatbuffers::Offset<VGF::Module>>(*modules) : 0;
  return VGF::CreateModuleTable(
      _fbb,
      modules__);
}

struct Description FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DescriptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE = 4,
    VT_STRIDES = 6
  };
  const ::flatbuffers::Vector<int64_t> *shape() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_SHAPE);
  }
  const ::flatbuffers::Vector<int64_t> *strides() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_STRIDES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           verifier.EndTable();
  }
};

struct DescriptionBuilder {
  typedef Description Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shape(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> shape) {
    fbb_.AddOffset(Description::VT_SHAPE, shape);
  }
  void add_strides(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> strides) {
    fbb_.AddOffset(Description::VT_STRIDES, strides);
  }
  explicit DescriptionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Description> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Description>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Description> CreateDescription(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> shape = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> strides = 0) {
  DescriptionBuilder builder_(_fbb);
  builder_.add_strides(strides);
  builder_.add_shape(shape);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Description> CreateDescriptionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *shape = nullptr,
    const std::vector<int64_t> *strides = nullptr) {
  auto shape__ = shape ? _fbb.CreateVector<int64_t>(*shape) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int64_t>(*strides) : 0;
  return VGF::CreateDescription(
      _fbb,
      shape__,
      strides__);
}

struct ModelResourceTableEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ModelResourceTableEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VK_DESCRIPTOR_TYPE = 4,
    VT_VK_FORMAT = 6,
    VT_CATEGORY = 8,
    VT_DESCRIPTION = 10
  };
  uint32_t vk_descriptor_type() const {
    return GetField<uint32_t>(VT_VK_DESCRIPTOR_TYPE, 0);
  }
  uint32_t vk_format() const {
    return GetField<uint32_t>(VT_VK_FORMAT, 0);
  }
  VGF::ResourceCategory category() const {
    return static_cast<VGF::ResourceCategory>(GetField<uint8_t>(VT_CATEGORY, 0));
  }
  const VGF::Description *description() const {
    return GetPointer<const VGF::Description *>(VT_DESCRIPTION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VK_DESCRIPTOR_TYPE, 4) &&
           VerifyField<uint32_t>(verifier, VT_VK_FORMAT, 4) &&
           VerifyField<uint8_t>(verifier, VT_CATEGORY, 1) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyTable(description()) &&
           verifier.EndTable();
  }
};

struct ModelResourceTableEntryBuilder {
  typedef ModelResourceTableEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_vk_descriptor_type(uint32_t vk_descriptor_type) {
    fbb_.AddElement<uint32_t>(ModelResourceTableEntry::VT_VK_DESCRIPTOR_TYPE, vk_descriptor_type, 0);
  }
  void add_vk_format(uint32_t vk_format) {
    fbb_.AddElement<uint32_t>(ModelResourceTableEntry::VT_VK_FORMAT, vk_format, 0);
  }
  void add_category(VGF::ResourceCategory category) {
    fbb_.AddElement<uint8_t>(ModelResourceTableEntry::VT_CATEGORY, static_cast<uint8_t>(category), 0);
  }
  void add_description(::flatbuffers::Offset<VGF::Description> description) {
    fbb_.AddOffset(ModelResourceTableEntry::VT_DESCRIPTION, description);
  }
  explicit ModelResourceTableEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ModelResourceTableEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ModelResourceTableEntry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ModelResourceTableEntry> CreateModelResourceTableEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t vk_descriptor_type = 0,
    uint32_t vk_format = 0,
    VGF::ResourceCategory category = VGF::ResourceCategory_INPUT,
    ::flatbuffers::Offset<VGF::Description> description = 0) {
  ModelResourceTableEntryBuilder builder_(_fbb);
  builder_.add_description(description);
  builder_.add_vk_format(vk_format);
  builder_.add_vk_descriptor_type(vk_descriptor_type);
  builder_.add_category(category);
  return builder_.Finish();
}

struct ModelResourceTable FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ModelResourceTableBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MRT_ENTRY = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<VGF::ModelResourceTableEntry>> *mrt_entry() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<VGF::ModelResourceTableEntry>> *>(VT_MRT_ENTRY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MRT_ENTRY) &&
           verifier.VerifyVector(mrt_entry()) &&
           verifier.VerifyVectorOfTables(mrt_entry()) &&
           verifier.EndTable();
  }
};

struct ModelResourceTableBuilder {
  typedef ModelResourceTable Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mrt_entry(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VGF::ModelResourceTableEntry>>> mrt_entry) {
    fbb_.AddOffset(ModelResourceTable::VT_MRT_ENTRY, mrt_entry);
  }
  explicit ModelResourceTableBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ModelResourceTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ModelResourceTable>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ModelResourceTable> CreateModelResourceTable(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VGF::ModelResourceTableEntry>>> mrt_entry = 0) {
  ModelResourceTableBuilder builder_(_fbb);
  builder_.add_mrt_entry(mrt_entry);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ModelResourceTable> CreateModelResourceTableDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<VGF::ModelResourceTableEntry>> *mrt_entry = nullptr) {
  auto mrt_entry__ = mrt_entry ? _fbb.CreateVector<::flatbuffers::Offset<VGF::ModelResourceTableEntry>>(*mrt_entry) : 0;
  return VGF::CreateModelResourceTable(
      _fbb,
      mrt_entry__);
}

struct BindingSlot FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BindingSlotBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BINDING = 4,
    VT_MRT_INDEX = 6
  };
  uint32_t binding() const {
    return GetField<uint32_t>(VT_BINDING, 0);
  }
  uint32_t mrt_index() const {
    return GetField<uint32_t>(VT_MRT_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_BINDING, 4) &&
           VerifyField<uint32_t>(verifier, VT_MRT_INDEX, 4) &&
           verifier.EndTable();
  }
};

struct BindingSlotBuilder {
  typedef BindingSlot Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_binding(uint32_t binding) {
    fbb_.AddElement<uint32_t>(BindingSlot::VT_BINDING, binding, 0);
  }
  void add_mrt_index(uint32_t mrt_index) {
    fbb_.AddElement<uint32_t>(BindingSlot::VT_MRT_INDEX, mrt_index, 0);
  }
  explicit BindingSlotBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BindingSlot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BindingSlot>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BindingSlot> CreateBindingSlot(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t binding = 0,
    uint32_t mrt_index = 0) {
  BindingSlotBuilder builder_(_fbb);
  builder_.add_mrt_index(mrt_index);
  builder_.add_binding(binding);
  return builder_.Finish();
}

struct DescriptorSetInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DescriptorSetInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BINDINGS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<VGF::BindingSlot>> *bindings() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<VGF::BindingSlot>> *>(VT_BINDINGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BINDINGS) &&
           verifier.VerifyVector(bindings()) &&
           verifier.VerifyVectorOfTables(bindings()) &&
           verifier.EndTable();
  }
};

struct DescriptorSetInfoBuilder {
  typedef DescriptorSetInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_bindings(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VGF::BindingSlot>>> bindings) {
    fbb_.AddOffset(DescriptorSetInfo::VT_BINDINGS, bindings);
  }
  explicit DescriptorSetInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DescriptorSetInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DescriptorSetInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DescriptorSetInfo> CreateDescriptorSetInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VGF::BindingSlot>>> bindings = 0) {
  DescriptorSetInfoBuilder builder_(_fbb);
  builder_.add_bindings(bindings);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DescriptorSetInfo> CreateDescriptorSetInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<VGF::BindingSlot>> *bindings = nullptr) {
  auto bindings__ = bindings ? _fbb.CreateVector<::flatbuffers::Offset<VGF::BindingSlot>>(*bindings) : 0;
  return VGF::CreateDescriptorSetInfo(
      _fbb,
      bindings__);
}

struct PushConstantRange FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PushConstantRangeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STAGE_FLAGS = 4,
    VT_OFFSET = 6,
    VT_SIZE = 8
  };
  uint32_t stage_flags() const {
    return GetField<uint32_t>(VT_STAGE_FLAGS, 0);
  }
  uint32_t offset() const {
    return GetField<uint32_t>(VT_OFFSET, 0);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_STAGE_FLAGS, 4) &&
           VerifyField<uint32_t>(verifier, VT_OFFSET, 4) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           verifier.EndTable();
  }
};

struct PushConstantRangeBuilder {
  typedef PushConstantRange Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_stage_flags(uint32_t stage_flags) {
    fbb_.AddElement<uint32_t>(PushConstantRange::VT_STAGE_FLAGS, stage_flags, 0);
  }
  void add_offset(uint32_t offset) {
    fbb_.AddElement<uint32_t>(PushConstantRange::VT_OFFSET, offset, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(PushConstantRange::VT_SIZE, size, 0);
  }
  explicit PushConstantRangeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PushConstantRange> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PushConstantRange>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PushConstantRange> CreatePushConstantRange(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t stage_flags = 0,
    uint32_t offset = 0,
    uint32_t size = 0) {
  PushConstantRangeBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_offset(offset);
  builder_.add_stage_flags(stage_flags);
  return builder_.Finish();
}

struct SegmentInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SegmentInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_NAME = 6,
    VT_MODULE_INDEX = 8,
    VT_SET_INFOS = 10,
    VT_INPUTS = 12,
    VT_OUTPUTS = 14,
    VT_CONSTANTS = 16,
    VT_DISPATCH_SHAPE = 18,
    VT_PUSH_CONSTANT_RANGES = 20
  };
  VGF::ModuleType type() const {
    return static_cast<VGF::ModuleType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint32_t module_index() const {
    return GetField<uint32_t>(VT_MODULE_INDEX, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<VGF::DescriptorSetInfo>> *set_infos() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<VGF::DescriptorSetInfo>> *>(VT_SET_INFOS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<VGF::BindingSlot>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<VGF::BindingSlot>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<VGF::BindingSlot>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<VGF::BindingSlot>> *>(VT_OUTPUTS);
  }
  const ::flatbuffers::Vector<uint32_t> *constants() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_CONSTANTS);
  }
  const ::flatbuffers::Vector<uint32_t> *dispatch_shape() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_DISPATCH_SHAPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<VGF::PushConstantRange>> *push_constant_ranges() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<VGF::PushConstantRange>> *>(VT_PUSH_CONSTANT_RANGES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_MODULE_INDEX, 4) &&
           VerifyOffset(verifier, VT_SET_INFOS) &&
           verifier.VerifyVector(set_infos()) &&
           verifier.VerifyVectorOfTables(set_infos()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfTables(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfTables(outputs()) &&
           VerifyOffset(verifier, VT_CONSTANTS) &&
           verifier.VerifyVector(constants()) &&
           VerifyOffset(verifier, VT_DISPATCH_SHAPE) &&
           verifier.VerifyVector(dispatch_shape()) &&
           VerifyOffset(verifier, VT_PUSH_CONSTANT_RANGES) &&
           verifier.VerifyVector(push_constant_ranges()) &&
           verifier.VerifyVectorOfTables(push_constant_ranges()) &&
           verifier.EndTable();
  }
};

struct SegmentInfoBuilder {
  typedef SegmentInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(VGF::ModuleType type) {
    fbb_.AddElement<uint8_t>(SegmentInfo::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(SegmentInfo::VT_NAME, name);
  }
  void add_module_index(uint32_t module_index) {
    fbb_.AddElement<uint32_t>(SegmentInfo::VT_MODULE_INDEX, module_index, 0);
  }
  void add_set_infos(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VGF::DescriptorSetInfo>>> set_infos) {
    fbb_.AddOffset(SegmentInfo::VT_SET_INFOS, set_infos);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VGF::BindingSlot>>> inputs) {
    fbb_.AddOffset(SegmentInfo::VT_INPUTS, inputs);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VGF::BindingSlot>>> outputs) {
    fbb_.AddOffset(SegmentInfo::VT_OUTPUTS, outputs);
  }
  void add_constants(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> constants) {
    fbb_.AddOffset(SegmentInfo::VT_CONSTANTS, constants);
  }
  void add_dispatch_shape(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> dispatch_shape) {
    fbb_.AddOffset(SegmentInfo::VT_DISPATCH_SHAPE, dispatch_shape);
  }
  void add_push_constant_ranges(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VGF::PushConstantRange>>> push_constant_ranges) {
    fbb_.AddOffset(SegmentInfo::VT_PUSH_CONSTANT_RANGES, push_constant_ranges);
  }
  explicit SegmentInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SegmentInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SegmentInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SegmentInfo> CreateSegmentInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    VGF::ModuleType type = VGF::ModuleType_COMPUTE,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint32_t module_index = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VGF::DescriptorSetInfo>>> set_infos = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VGF::BindingSlot>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VGF::BindingSlot>>> outputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> constants = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> dispatch_shape = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VGF::PushConstantRange>>> push_constant_ranges = 0) {
  SegmentInfoBuilder builder_(_fbb);
  builder_.add_push_constant_ranges(push_constant_ranges);
  builder_.add_dispatch_shape(dispatch_shape);
  builder_.add_constants(constants);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_set_infos(set_infos);
  builder_.add_module_index(module_index);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SegmentInfo> CreateSegmentInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    VGF::ModuleType type = VGF::ModuleType_COMPUTE,
    const char *name = nullptr,
    uint32_t module_index = 0,
    const std::vector<::flatbuffers::Offset<VGF::DescriptorSetInfo>> *set_infos = nullptr,
    const std::vector<::flatbuffers::Offset<VGF::BindingSlot>> *inputs = nullptr,
    const std::vector<::flatbuffers::Offset<VGF::BindingSlot>> *outputs = nullptr,
    const std::vector<uint32_t> *constants = nullptr,
    const std::vector<uint32_t> *dispatch_shape = nullptr,
    const std::vector<::flatbuffers::Offset<VGF::PushConstantRange>> *push_constant_ranges = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto set_infos__ = set_infos ? _fbb.CreateVector<::flatbuffers::Offset<VGF::DescriptorSetInfo>>(*set_infos) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<VGF::BindingSlot>>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<VGF::BindingSlot>>(*outputs) : 0;
  auto constants__ = constants ? _fbb.CreateVector<uint32_t>(*constants) : 0;
  auto dispatch_shape__ = dispatch_shape ? _fbb.CreateVector<uint32_t>(*dispatch_shape) : 0;
  auto push_constant_ranges__ = push_constant_ranges ? _fbb.CreateVector<::flatbuffers::Offset<VGF::PushConstantRange>>(*push_constant_ranges) : 0;
  return VGF::CreateSegmentInfo(
      _fbb,
      type,
      name__,
      module_index,
      set_infos__,
      inputs__,
      outputs__,
      constants__,
      dispatch_shape__,
      push_constant_ranges__);
}

struct ModelSequenceTable FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ModelSequenceTableBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEGMENTS = 4,
    VT_INPUTS = 6,
    VT_OUTPUTS = 8,
    VT_INPUT_NAMES = 10,
    VT_OUTPUT_NAMES = 12
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<VGF::SegmentInfo>> *segments() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<VGF::SegmentInfo>> *>(VT_SEGMENTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<VGF::BindingSlot>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<VGF::BindingSlot>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<VGF::BindingSlot>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<VGF::BindingSlot>> *>(VT_OUTPUTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *input_names() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_INPUT_NAMES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *output_names() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_OUTPUT_NAMES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SEGMENTS) &&
           verifier.VerifyVector(segments()) &&
           verifier.VerifyVectorOfTables(segments()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfTables(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfTables(outputs()) &&
           VerifyOffset(verifier, VT_INPUT_NAMES) &&
           verifier.VerifyVector(input_names()) &&
           verifier.VerifyVectorOfStrings(input_names()) &&
           VerifyOffset(verifier, VT_OUTPUT_NAMES) &&
           verifier.VerifyVector(output_names()) &&
           verifier.VerifyVectorOfStrings(output_names()) &&
           verifier.EndTable();
  }
};

struct ModelSequenceTableBuilder {
  typedef ModelSequenceTable Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_segments(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VGF::SegmentInfo>>> segments) {
    fbb_.AddOffset(ModelSequenceTable::VT_SEGMENTS, segments);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VGF::BindingSlot>>> inputs) {
    fbb_.AddOffset(ModelSequenceTable::VT_INPUTS, inputs);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VGF::BindingSlot>>> outputs) {
    fbb_.AddOffset(ModelSequenceTable::VT_OUTPUTS, outputs);
  }
  void add_input_names(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> input_names) {
    fbb_.AddOffset(ModelSequenceTable::VT_INPUT_NAMES, input_names);
  }
  void add_output_names(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> output_names) {
    fbb_.AddOffset(ModelSequenceTable::VT_OUTPUT_NAMES, output_names);
  }
  explicit ModelSequenceTableBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ModelSequenceTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ModelSequenceTable>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ModelSequenceTable> CreateModelSequenceTable(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VGF::SegmentInfo>>> segments = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VGF::BindingSlot>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VGF::BindingSlot>>> outputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> input_names = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> output_names = 0) {
  ModelSequenceTableBuilder builder_(_fbb);
  builder_.add_output_names(output_names);
  builder_.add_input_names(input_names);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_segments(segments);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ModelSequenceTable> CreateModelSequenceTableDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<VGF::SegmentInfo>> *segments = nullptr,
    const std::vector<::flatbuffers::Offset<VGF::BindingSlot>> *inputs = nullptr,
    const std::vector<::flatbuffers::Offset<VGF::BindingSlot>> *outputs = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *input_names = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *output_names = nullptr) {
  auto segments__ = segments ? _fbb.CreateVector<::flatbuffers::Offset<VGF::SegmentInfo>>(*segments) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<VGF::BindingSlot>>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<VGF::BindingSlot>>(*outputs) : 0;
  auto input_names__ = input_names ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*input_names) : 0;
  auto output_names__ = output_names ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*output_names) : 0;
  return VGF::CreateModelSequenceTable(
      _fbb,
      segments__,
      inputs__,
      outputs__,
      input_names__,
      output_names__);
}

struct ConstantData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConstantDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MRT_INDEX = 4,
    VT_SPARSITY_DIMENSION = 6,
    VT_RAW = 8
  };
  uint32_t mrt_index() const {
    return GetField<uint32_t>(VT_MRT_INDEX, 0);
  }
  int64_t sparsity_dimension() const {
    return GetField<int64_t>(VT_SPARSITY_DIMENSION, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *raw() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_RAW);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MRT_INDEX, 4) &&
           VerifyField<int64_t>(verifier, VT_SPARSITY_DIMENSION, 8) &&
           VerifyOffset(verifier, VT_RAW) &&
           verifier.VerifyVector(raw()) &&
           verifier.EndTable();
  }
};

struct ConstantDataBuilder {
  typedef ConstantData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mrt_index(uint32_t mrt_index) {
    fbb_.AddElement<uint32_t>(ConstantData::VT_MRT_INDEX, mrt_index, 0);
  }
  void add_sparsity_dimension(int64_t sparsity_dimension) {
    fbb_.AddElement<int64_t>(ConstantData::VT_SPARSITY_DIMENSION, sparsity_dimension, 0);
  }
  void add_raw(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> raw) {
    fbb_.AddOffset(ConstantData::VT_RAW, raw);
  }
  explicit ConstantDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConstantData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConstantData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConstantData> CreateConstantData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t mrt_index = 0,
    int64_t sparsity_dimension = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> raw = 0) {
  ConstantDataBuilder builder_(_fbb);
  builder_.add_sparsity_dimension(sparsity_dimension);
  builder_.add_raw(raw);
  builder_.add_mrt_index(mrt_index);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ConstantData> CreateConstantDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t mrt_index = 0,
    int64_t sparsity_dimension = 0,
    const std::vector<uint8_t> *raw = nullptr) {
  if (raw) { _fbb.ForceVectorAlignment(raw->size(), sizeof(uint8_t), 8); }
  auto raw__ = raw ? _fbb.CreateVector<uint8_t>(*raw) : 0;
  return VGF::CreateConstantData(
      _fbb,
      mrt_index,
      sparsity_dimension,
      raw__);
}

struct ConstantSection FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConstantSectionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<VGF::ConstantData>> *data() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<VGF::ConstantData>> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
};

struct ConstantSectionBuilder {
  typedef ConstantSection Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VGF::ConstantData>>> data) {
    fbb_.AddOffset(ConstantSection::VT_DATA, data);
  }
  explicit ConstantSectionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConstantSection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConstantSection>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConstantSection> CreateConstantSection(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VGF::ConstantData>>> data = 0) {
  ConstantSectionBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ConstantSection> CreateConstantSectionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<VGF::ConstantData>> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<::flatbuffers::Offset<VGF::ConstantData>>(*data) : 0;
  return VGF::CreateConstantSection(
      _fbb,
      data__);
}

inline bool VerifyModuleCode(::flatbuffers::Verifier &verifier, const void *obj, ModuleCode type) {
  switch (type) {
    case ModuleCode_NONE: {
      return true;
    }
    case ModuleCode_SPIRV: {
      auto ptr = reinterpret_cast<const VGF::SPIRV *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyModuleCodeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyModuleCode(
        verifier,  values->Get(i), types->GetEnum<ModuleCode>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace VGF

#endif  // FLATBUFFERS_GENERATED_VGF_VGF_H_
