/*
 * SPDX-FileCopyrightText: Copyright 2023-2025 Arm Limited and/or its affiliates <open-source-office@arm.com>
 * SPDX-License-Identifier: Apache-2.0
 */

#version 460
#extension GL_EXT_shader_explicit_arithmetic_types : enable
#extension GL_ARM_tensors : enable

// Maximum supported rank
#define RANK_MAX 6

#define NAN (0.0 / 0.0)
#define PI 3.141592653589793238462643383279502884197

// NAN Modes
#define NAN_MODE_PROPAGATE 1
#define NAN_MODE_IGNORE 2

// Types
#define TYPE_BOOL 0x6231   // "b1"
#define TYPE_INT8 0x6931   // "i1"
#define TYPE_INT16 0x6932  // "i2"
#define TYPE_INT32 0x6934  // "i4"
#define TYPE_INT64 0x6938  // "i8"
#define TYPE_HALF 0x6632   // "f2"
#define TYPE_FLOAT 0x6634  // "f4"
#define TYPE_DOUBLE 0x6638 // "f8"

#define IS_BOOL(t) (t == TYPE_BOOL)
#define IS_INTEGER(t) ((t >> 8) == 0x69)
#define IS_FLOAT(t) ((t >> 8) == 0x66)

#define applyBroadcast(shape, index, coords)                                                                           \
    {                                                                                                                  \
        for (int i = int(shape.length() - 1); i >= 0; i--) {                                                           \
            coords[i] = index[i];                                                                                      \
            if (shape[i] == 1) {                                                                                       \
                coords[i] = 0;                                                                                         \
            }                                                                                                          \
        }                                                                                                              \
    }

#define offsetToIndex(shape, offset, index)                                                                            \
    {                                                                                                                  \
        uint off = offset;                                                                                             \
        for (int i = int(index.length() - 1); i >= 0; i--) {                                                           \
            index[i] = off % shape[i];                                                                                 \
            off /= shape[i];                                                                                           \
        }                                                                                                              \
                                                                                                                       \
        if (off > 0) {                                                                                                 \
            return;                                                                                                    \
        }                                                                                                              \
    }

#define getShape(shape, tensorARM)                                                                                     \
    {                                                                                                                  \
        if (shape.length() == 6) {                                                                                     \
            shape[0] = tensorSizeARM(tensorARM, 0);                                                                    \
            shape[1] = tensorSizeARM(tensorARM, 1);                                                                    \
            shape[2] = tensorSizeARM(tensorARM, 2);                                                                    \
            shape[3] = tensorSizeARM(tensorARM, 3);                                                                    \
            shape[4] = tensorSizeARM(tensorARM, 4);                                                                    \
            shape[5] = tensorSizeARM(tensorARM, 5);                                                                    \
        } else if (shape.length() == 5) {                                                                              \
            shape[0] = tensorSizeARM(tensorARM, 0);                                                                    \
            shape[1] = tensorSizeARM(tensorARM, 1);                                                                    \
            shape[2] = tensorSizeARM(tensorARM, 2);                                                                    \
            shape[3] = tensorSizeARM(tensorARM, 3);                                                                    \
            shape[4] = tensorSizeARM(tensorARM, 4);                                                                    \
        } else if (shape.length() == 4) {                                                                              \
            shape[0] = tensorSizeARM(tensorARM, 0);                                                                    \
            shape[1] = tensorSizeARM(tensorARM, 1);                                                                    \
            shape[2] = tensorSizeARM(tensorARM, 2);                                                                    \
            shape[3] = tensorSizeARM(tensorARM, 3);                                                                    \
        } else if (shape.length() == 3) {                                                                              \
            shape[0] = tensorSizeARM(tensorARM, 0);                                                                    \
            shape[1] = tensorSizeARM(tensorARM, 1);                                                                    \
            shape[2] = tensorSizeARM(tensorARM, 2);                                                                    \
        } else if (shape.length() == 2) {                                                                              \
            shape[0] = tensorSizeARM(tensorARM, 0);                                                                    \
            shape[1] = tensorSizeARM(tensorARM, 1);                                                                    \
        } else if (shape.length() == 1) {                                                                              \
            shape[0] = tensorSizeARM(tensorARM, 0);                                                                    \
        }                                                                                                              \
    }

#define getIndex(tensorARM, index)                                                                                     \
    {                                                                                                                  \
        const uint offset =                                                                                            \
            gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x;               \
                                                                                                                       \
        uint[index.length()] shape;                                                                                    \
        getShape(shape, tensorARM);                                                                                    \
                                                                                                                       \
        offsetToIndex(shape, offset, index);                                                                           \
    }

#define getIndex2(tensorARM, index)                                                                                    \
    {                                                                                                                  \
        const uint offset =                                                                                            \
            gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x;               \
                                                                                                                       \
        uint[index.length()] shape;                                                                                    \
        shape[0] = tensorSizeARM(tensorARM, 0);                                                                        \
        shape[1] = tensorSizeARM(tensorARM, 1);                                                                        \
                                                                                                                       \
        offsetToIndex(shape, offset, index);                                                                           \
    }

#define getIndex3(tensorARM, index)                                                                                    \
    {                                                                                                                  \
        const uint offset =                                                                                            \
            gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x;               \
                                                                                                                       \
        uint[index.length()] shape;                                                                                    \
        shape[0] = tensorSizeARM(tensorARM, 0);                                                                        \
        shape[1] = tensorSizeARM(tensorARM, 1);                                                                        \
        shape[2] = tensorSizeARM(tensorARM, 2);                                                                        \
                                                                                                                       \
        offsetToIndex(shape, offset, index);                                                                           \
    }

#define getIndex4(tensorARM, index)                                                                                    \
    {                                                                                                                  \
        const uint offset =                                                                                            \
            gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x;               \
                                                                                                                       \
        uint[index.length()] shape;                                                                                    \
        shape[0] = tensorSizeARM(tensorARM, 0);                                                                        \
        shape[1] = tensorSizeARM(tensorARM, 1);                                                                        \
        shape[2] = tensorSizeARM(tensorARM, 2);                                                                        \
        shape[3] = tensorSizeARM(tensorARM, 3);                                                                        \
                                                                                                                       \
        offsetToIndex(shape, offset, index);                                                                           \
    }

#define getIndex5(tensorARM, index)                                                                                    \
    {                                                                                                                  \
        const uint offset =                                                                                            \
            gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x;               \
                                                                                                                       \
        uint[index.length()] shape;                                                                                    \
        shape[0] = tensorSizeARM(tensorARM, 0);                                                                        \
        shape[1] = tensorSizeARM(tensorARM, 1);                                                                        \
        shape[2] = tensorSizeARM(tensorARM, 2);                                                                        \
        shape[3] = tensorSizeARM(tensorARM, 3);                                                                        \
        shape[4] = tensorSizeARM(tensorARM, 4);                                                                        \
                                                                                                                       \
        offsetToIndex(shape, offset, index);                                                                           \
    }
/*
 * SPDX-FileCopyrightText: Copyright 2023-2025 Arm Limited and/or its affiliates <open-source-office@arm.com>
 * SPDX-License-Identifier: Apache-2.0
 */

#define IN_T %in_t%
#define OUT_T %out_t%
#define WEIGHT_T %weight_t%
#define TYPE_ACC %acc_t_type%
#define ACC_T %acc_t%

#if TYPE_ACC == TYPE_INT64
    #define VEC4 dvec4
#elif TYPE_ACC == TYPE_INT32
    #define VEC4 ivec4
#else
    #define VEC4 vec4
#endif

layout(local_size_x = %warpX%) in;

layout(push_constant) uniform PushConstants {
    int32_t inputZeroPoint;
    int32_t weightZeroPoint;
    int32_t pad[6];             // [d0, d1, top, bottom, left, right]
    int32_t stride[3];          // [d, y, x]
    int32_t dilation[3];        // [d, y, x]
} pushConstants;

layout(set = 0, binding = 0) uniform tensorARM<OUT_T, 5> outputData;       // [N, OD, OH, OW, OC]
layout(set = 1, binding = 0) uniform tensorARM<IN_T, 5> inputData;         // [N, ID, IH, IW, IC]
layout(set = 2, binding = 0) uniform tensorARM<WEIGHT_T, 5> weightsData;   // [OC, KD, KH, KW, IC]
layout(set = 3, binding = 0) uniform tensorARM<OUT_T, 1> biasesData;       // [BC]

void main() {
    uint[5] index;
    getIndex5(outputData, index);

    ACC_T acc = ACC_T(0);

    uint n = index[0];
    uint od = index[1];
    uint oy = index[2];
    uint ox = index[3];
    uint oc = index[4];

    uint id = od * pushConstants.stride[0] - pushConstants.pad[0];
    uint iy = oy * pushConstants.stride[1] - pushConstants.pad[2];
    uint ix = ox * pushConstants.stride[2] - pushConstants.pad[4];

    uint KD = tensorSizeARM(weightsData, 1);
    uint KH = tensorSizeARM(weightsData, 2);
    uint KW = tensorSizeARM(weightsData, 3);
    uint IC = tensorSizeARM(weightsData, 4);

    uint ID = tensorSizeARM(inputData, 1);
    uint IH = tensorSizeARM(inputData, 2);
    uint IW = tensorSizeARM(inputData, 3);

    for (uint kd = 0; kd < KD; kd++) {
        for (uint ky = 0; ky < KH; ky++) {
            for (uint kx = 0; kx < KW; kx++) {
                uint d = id + kd * pushConstants.dilation[0];
                uint y = iy + ky * pushConstants.dilation[1];
                uint x = ix + kx * pushConstants.dilation[2];

                if (d < ID && y < IH && x < IW) {
                    for (uint ic = 0; ic < IC; ic += 4) {
                        IN_T tempValue[4];
                        tensorReadARM(inputData, uint[](n, d, y, x, ic), tempValue);
                        VEC4 value = VEC4(tempValue[0], tempValue[1], tempValue[2], tempValue[3]);

                        WEIGHT_T tempWeight[4];
                        tensorReadARM(weightsData, uint[](oc, kd, ky, kx, ic), tempWeight);
                        VEC4 weight = VEC4(tempWeight[0], tempWeight[1], tempWeight[2], tempWeight[3]);

                        VEC4 outValue = VEC4(value[0], value[1], value[2], value[3]) - pushConstants.inputZeroPoint;
                        VEC4 outWeight = VEC4(weight[0], weight[1], weight[2], weight[3]) - pushConstants.weightZeroPoint;
                        VEC4 mul = outValue * outWeight;

                        for (uint idx = 0; idx < 4 && ic + idx < IC; ++idx) {
                            acc += ACC_T(mul[idx]);
                        }
                    }
                }
            }
        }
    }

    OUT_T bias;
    tensorReadARM(biasesData, uint[](tensorSizeARM(biasesData, 0) == 1 ? 0 : oc), bias);
    bias += OUT_T(acc);

    tensorWriteARM(outputData, index, bias);
}
