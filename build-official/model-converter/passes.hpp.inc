/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_CHECKCONSTANTSPARSITYPASS
#define GEN_PASS_DECL_DENSERESOURCEINLINERPASS
#define GEN_PASS_DECL_MODELPARTITIONMARKINGPASS
#define GEN_PASS_DECL_MODELPARTITIONINGPASS
#define GEN_PASS_DECL_SERIALIZEVGFPASS
#define GEN_PASS_DECL_SIGNLESSINTEGERMARKINGPASS
#define GEN_PASS_DECL_TOSASHAPEDVERIFICATIONPASS
#define GEN_PASS_DECL_TYPENARROWINGPASS
#define GEN_PASS_DECL_VGFCONSTANTSPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// CheckConstantSparsityPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CHECKCONSTANTSPARSITYPASS
std::unique_ptr<::mlir::Pass> createCheckConstantSparsityPass();
#undef GEN_PASS_DECL_CHECKCONSTANTSPARSITYPASS
#endif // GEN_PASS_DECL_CHECKCONSTANTSPARSITYPASS
#ifdef GEN_PASS_DEF_CHECKCONSTANTSPARSITYPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createCheckConstantSparsityPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class CheckConstantSparsityPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = CheckConstantSparsityPassBase;

  CheckConstantSparsityPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  CheckConstantSparsityPassBase(const CheckConstantSparsityPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("check-constant-sparsity");
  }
  ::llvm::StringRef getArgument() const override { return "check-constant-sparsity"; }

  ::llvm::StringRef getDescription() const override { return "Detect if a TOSA constant is sparse"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CheckConstantSparsityPass");
  }
  ::llvm::StringRef getName() const override { return "CheckConstantSparsityPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CheckConstantSparsityPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createCheckConstantSparsityPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createCheckConstantSparsityPass() {
  return impl::createCheckConstantSparsityPass();
}
#undef GEN_PASS_DEF_CHECKCONSTANTSPARSITYPASS
#endif // GEN_PASS_DEF_CHECKCONSTANTSPARSITYPASS

//===----------------------------------------------------------------------===//
// DenseResourceInlinerPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_DENSERESOURCEINLINERPASS
std::unique_ptr<::mlir::Pass> createDenseResourceInlinerPass();
#undef GEN_PASS_DECL_DENSERESOURCEINLINERPASS
#endif // GEN_PASS_DECL_DENSERESOURCEINLINERPASS
#ifdef GEN_PASS_DEF_DENSERESOURCEINLINERPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createDenseResourceInlinerPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class DenseResourceInlinerPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = DenseResourceInlinerPassBase;

  DenseResourceInlinerPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DenseResourceInlinerPassBase(const DenseResourceInlinerPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("dense-resource-inliner");
  }
  ::llvm::StringRef getArgument() const override { return "dense-resource-inliner"; }

  ::llvm::StringRef getDescription() const override { return "Inline DenseResourceElementsAttr into DenseElementsAttr"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DenseResourceInlinerPass");
  }
  ::llvm::StringRef getName() const override { return "DenseResourceInlinerPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DenseResourceInlinerPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createDenseResourceInlinerPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createDenseResourceInlinerPass() {
  return impl::createDenseResourceInlinerPass();
}
#undef GEN_PASS_DEF_DENSERESOURCEINLINERPASS
#endif // GEN_PASS_DEF_DENSERESOURCEINLINERPASS

//===----------------------------------------------------------------------===//
// ModelPartitionMarkingPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MODELPARTITIONMARKINGPASS
std::unique_ptr<::mlir::Pass> createModelPartitionMarkingPass();
#undef GEN_PASS_DECL_MODELPARTITIONMARKINGPASS
#endif // GEN_PASS_DECL_MODELPARTITIONMARKINGPASS
#ifdef GEN_PASS_DEF_MODELPARTITIONMARKINGPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createModelPartitionMarkingPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class ModelPartitionMarkingPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ModelPartitionMarkingPassBase;

  ModelPartitionMarkingPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ModelPartitionMarkingPassBase(const ModelPartitionMarkingPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("model-partition-marking");
  }
  ::llvm::StringRef getArgument() const override { return "model-partition-marking"; }

  ::llvm::StringRef getDescription() const override { return "Mark each operation in the model with a partition attribute"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ModelPartitionMarkingPass");
  }
  ::llvm::StringRef getName() const override { return "ModelPartitionMarkingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ModelPartitionMarkingPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createModelPartitionMarkingPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createModelPartitionMarkingPass() {
  return impl::createModelPartitionMarkingPass();
}
#undef GEN_PASS_DEF_MODELPARTITIONMARKINGPASS
#endif // GEN_PASS_DEF_MODELPARTITIONMARKINGPASS

//===----------------------------------------------------------------------===//
// ModelPartitioningPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MODELPARTITIONINGPASS
struct ModelPartitioningPassOptions {
  bool analysis = false;
};
std::unique_ptr<::mlir::Pass> createModelPartitioningPass();
std::unique_ptr<::mlir::Pass> createModelPartitioningPass(const ModelPartitioningPassOptions &options);
#undef GEN_PASS_DECL_MODELPARTITIONINGPASS
#endif // GEN_PASS_DECL_MODELPARTITIONINGPASS
#ifdef GEN_PASS_DEF_MODELPARTITIONINGPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createModelPartitioningPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createModelPartitioningPass(const ModelPartitioningPassOptions &options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ModelPartitioningPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ModelPartitioningPassBase;

  ModelPartitioningPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ModelPartitioningPassBase(const ModelPartitioningPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("model-partitioning");
  }
  ::llvm::StringRef getArgument() const override { return "model-partitioning"; }

  ::llvm::StringRef getDescription() const override { return "Split the model in several sub-modules one per partition"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ModelPartitioningPass");
  }
  ::llvm::StringRef getName() const override { return "ModelPartitioningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ModelPartitioningPassBase<DerivedT>)

  ModelPartitioningPassBase(const ModelPartitioningPassOptions &options) : ModelPartitioningPassBase() {
    analysis = options.analysis;
  }
protected:
  ::mlir::Pass::Option<bool> analysis{*this, "analysis", ::llvm::cl::desc("Analysis"), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createModelPartitioningPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createModelPartitioningPass(const ModelPartitioningPassOptions &options) {
    return std::make_unique<DerivedT>(options);
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createModelPartitioningPass() {
  return impl::createModelPartitioningPass();
}

std::unique_ptr<::mlir::Pass> createModelPartitioningPass(const ModelPartitioningPassOptions &options) {
  return impl::createModelPartitioningPass(options);
}
#undef GEN_PASS_DEF_MODELPARTITIONINGPASS
#endif // GEN_PASS_DEF_MODELPARTITIONINGPASS

//===----------------------------------------------------------------------===//
// SerializeVGFPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SERIALIZEVGFPASS
struct SerializeVGFPassOptions {
  bool emitDebugInfo = false;
};
std::unique_ptr<::mlir::Pass> createSerializeVGFPass();
std::unique_ptr<::mlir::Pass> createSerializeVGFPass(const SerializeVGFPassOptions &options);
#undef GEN_PASS_DECL_SERIALIZEVGFPASS
#endif // GEN_PASS_DECL_SERIALIZEVGFPASS
#ifdef GEN_PASS_DEF_SERIALIZEVGFPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createSerializeVGFPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createSerializeVGFPass(const SerializeVGFPassOptions &options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class SerializeVGFPassBase : public ::mlir::OperationPass<mlir::vgf::SequenceOp> {
public:
  using Base = SerializeVGFPassBase;

  SerializeVGFPassBase() : ::mlir::OperationPass<mlir::vgf::SequenceOp>(::mlir::TypeID::get<DerivedT>()) {}
  SerializeVGFPassBase(const SerializeVGFPassBase &other) : ::mlir::OperationPass<mlir::vgf::SequenceOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("serialize-vgf");
  }
  ::llvm::StringRef getArgument() const override { return "serialize-vgf"; }

  ::llvm::StringRef getDescription() const override { return "Serialize VGF MLIR to VGF binary"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SerializeVGFPass");
  }
  ::llvm::StringRef getName() const override { return "SerializeVGFPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SerializeVGFPassBase<DerivedT>)

  SerializeVGFPassBase(const SerializeVGFPassOptions &options) : SerializeVGFPassBase() {
    emitDebugInfo = options.emitDebugInfo;
  }
protected:
  ::mlir::Pass::Option<bool> emitDebugInfo{*this, "emitDebugInfo", ::llvm::cl::desc("Emit debug information"), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createSerializeVGFPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createSerializeVGFPass(const SerializeVGFPassOptions &options) {
    return std::make_unique<DerivedT>(options);
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createSerializeVGFPass() {
  return impl::createSerializeVGFPass();
}

std::unique_ptr<::mlir::Pass> createSerializeVGFPass(const SerializeVGFPassOptions &options) {
  return impl::createSerializeVGFPass(options);
}
#undef GEN_PASS_DEF_SERIALIZEVGFPASS
#endif // GEN_PASS_DEF_SERIALIZEVGFPASS

//===----------------------------------------------------------------------===//
// SignlessIntegerMarkingPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SIGNLESSINTEGERMARKINGPASS
std::unique_ptr<::mlir::Pass> createSignlessIntegerMarkingPass();
#undef GEN_PASS_DECL_SIGNLESSINTEGERMARKINGPASS
#endif // GEN_PASS_DECL_SIGNLESSINTEGERMARKINGPASS
#ifdef GEN_PASS_DEF_SIGNLESSINTEGERMARKINGPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createSignlessIntegerMarkingPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class SignlessIntegerMarkingPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = SignlessIntegerMarkingPassBase;

  SignlessIntegerMarkingPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SignlessIntegerMarkingPassBase(const SignlessIntegerMarkingPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("signless-integer-marking");
  }
  ::llvm::StringRef getArgument() const override { return "signless-integer-marking"; }

  ::llvm::StringRef getDescription() const override { return "Mark signless integers as signed or unsigned"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SignlessIntegerMarkingPass");
  }
  ::llvm::StringRef getName() const override { return "SignlessIntegerMarkingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SignlessIntegerMarkingPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createSignlessIntegerMarkingPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createSignlessIntegerMarkingPass() {
  return impl::createSignlessIntegerMarkingPass();
}
#undef GEN_PASS_DEF_SIGNLESSINTEGERMARKINGPASS
#endif // GEN_PASS_DEF_SIGNLESSINTEGERMARKINGPASS

//===----------------------------------------------------------------------===//
// TosaShapedVerificationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TOSASHAPEDVERIFICATIONPASS
std::unique_ptr<::mlir::Pass> createTosaShapedVerificationPass();
#undef GEN_PASS_DECL_TOSASHAPEDVERIFICATIONPASS
#endif // GEN_PASS_DECL_TOSASHAPEDVERIFICATIONPASS
#ifdef GEN_PASS_DEF_TOSASHAPEDVERIFICATIONPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTosaShapedVerificationPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TosaShapedVerificationPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaShapedVerificationPassBase;

  TosaShapedVerificationPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaShapedVerificationPassBase(const TosaShapedVerificationPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-shape-verif");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-shape-verif"; }

  ::llvm::StringRef getDescription() const override { return "Optional pass that asserts no tensors in the graph are unranked or have dynamic shapes."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaShapedVerificationPass");
  }
  ::llvm::StringRef getName() const override { return "TosaShapedVerificationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaShapedVerificationPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTosaShapedVerificationPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTosaShapedVerificationPass() {
  return impl::createTosaShapedVerificationPass();
}
#undef GEN_PASS_DEF_TOSASHAPEDVERIFICATIONPASS
#endif // GEN_PASS_DEF_TOSASHAPEDVERIFICATIONPASS

//===----------------------------------------------------------------------===//
// TypeNarrowingPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TYPENARROWINGPASS
struct TypeNarrowingPassOptions {
  TypeNarrowingMode mode = TypeNarrowingMode::Full;
};
std::unique_ptr<::mlir::Pass> createTypeNarrowingPass();
std::unique_ptr<::mlir::Pass> createTypeNarrowingPass(const TypeNarrowingPassOptions &options);
#undef GEN_PASS_DECL_TYPENARROWINGPASS
#endif // GEN_PASS_DECL_TYPENARROWINGPASS
#ifdef GEN_PASS_DEF_TYPENARROWINGPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTypeNarrowingPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createTypeNarrowingPass(const TypeNarrowingPassOptions &options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class TypeNarrowingPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TypeNarrowingPassBase;

  TypeNarrowingPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TypeNarrowingPassBase(const TypeNarrowingPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("type-narrowing");
  }
  ::llvm::StringRef getArgument() const override { return "type-narrowing"; }

  ::llvm::StringRef getDescription() const override { return "Narrow types of operations' operands/results"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TypeNarrowingPass");
  }
  ::llvm::StringRef getName() const override { return "TypeNarrowingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TypeNarrowingPassBase<DerivedT>)

  TypeNarrowingPassBase(const TypeNarrowingPassOptions &options) : TypeNarrowingPassBase() {
    mode = options.mode;
  }
protected:
  ::mlir::Pass::Option<TypeNarrowingMode> mode{*this, "mode", ::llvm::cl::desc("Type narrowing"), ::llvm::cl::init(TypeNarrowingMode::Full), ::llvm::cl::values(
               clEnumValN(TypeNarrowingMode::Full, "full", "Full type narrowing"),
               clEnumValN(TypeNarrowingMode::Partial, "partial", "Partial type narrowing"),
               clEnumValN(TypeNarrowingMode::FullPreserveIO, "full_preserve_io", "Full type narrowing with i/o types preserved")
            )};
private:

  friend std::unique_ptr<::mlir::Pass> createTypeNarrowingPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createTypeNarrowingPass(const TypeNarrowingPassOptions &options) {
    return std::make_unique<DerivedT>(options);
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTypeNarrowingPass() {
  return impl::createTypeNarrowingPass();
}

std::unique_ptr<::mlir::Pass> createTypeNarrowingPass(const TypeNarrowingPassOptions &options) {
  return impl::createTypeNarrowingPass(options);
}
#undef GEN_PASS_DEF_TYPENARROWINGPASS
#endif // GEN_PASS_DEF_TYPENARROWINGPASS

//===----------------------------------------------------------------------===//
// VGFConstantsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_VGFCONSTANTSPASS
std::unique_ptr<::mlir::Pass> createVGFConstantsPass();
#undef GEN_PASS_DECL_VGFCONSTANTSPASS
#endif // GEN_PASS_DECL_VGFCONSTANTSPASS
#ifdef GEN_PASS_DEF_VGFCONSTANTSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createVGFConstantsPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class VGFConstantsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = VGFConstantsPassBase;

  VGFConstantsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  VGFConstantsPassBase(const VGFConstantsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("vgf-constants");
  }
  ::llvm::StringRef getArgument() const override { return "vgf-constants"; }

  ::llvm::StringRef getDescription() const override { return "Serialize TOSA Constants to VGF"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VGFConstantsPass");
  }
  ::llvm::StringRef getName() const override { return "VGFConstantsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VGFConstantsPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createVGFConstantsPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createVGFConstantsPass() {
  return impl::createVGFConstantsPass();
}
#undef GEN_PASS_DEF_VGFCONSTANTSPASS
#endif // GEN_PASS_DEF_VGFCONSTANTSPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// CheckConstantSparsityPass Registration
//===----------------------------------------------------------------------===//

inline void registerCheckConstantSparsityPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createCheckConstantSparsityPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerCheckConstantSparsityPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createCheckConstantSparsityPass();
  });
}

//===----------------------------------------------------------------------===//
// DenseResourceInlinerPass Registration
//===----------------------------------------------------------------------===//

inline void registerDenseResourceInlinerPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createDenseResourceInlinerPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerDenseResourceInlinerPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createDenseResourceInlinerPass();
  });
}

//===----------------------------------------------------------------------===//
// ModelPartitionMarkingPass Registration
//===----------------------------------------------------------------------===//

inline void registerModelPartitionMarkingPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createModelPartitionMarkingPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerModelPartitionMarkingPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createModelPartitionMarkingPass();
  });
}

//===----------------------------------------------------------------------===//
// ModelPartitioningPass Registration
//===----------------------------------------------------------------------===//

inline void registerModelPartitioningPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createModelPartitioningPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerModelPartitioningPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createModelPartitioningPass();
  });
}

//===----------------------------------------------------------------------===//
// SerializeVGFPass Registration
//===----------------------------------------------------------------------===//

inline void registerSerializeVGFPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createSerializeVGFPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSerializeVGFPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createSerializeVGFPass();
  });
}

//===----------------------------------------------------------------------===//
// SignlessIntegerMarkingPass Registration
//===----------------------------------------------------------------------===//

inline void registerSignlessIntegerMarkingPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createSignlessIntegerMarkingPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSignlessIntegerMarkingPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createSignlessIntegerMarkingPass();
  });
}

//===----------------------------------------------------------------------===//
// TosaShapedVerificationPass Registration
//===----------------------------------------------------------------------===//

inline void registerTosaShapedVerificationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaShapedVerificationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTosaShapedVerificationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTosaShapedVerificationPass();
  });
}

//===----------------------------------------------------------------------===//
// TypeNarrowingPass Registration
//===----------------------------------------------------------------------===//

inline void registerTypeNarrowingPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTypeNarrowingPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTypeNarrowingPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTypeNarrowingPass();
  });
}

//===----------------------------------------------------------------------===//
// VGFConstantsPass Registration
//===----------------------------------------------------------------------===//

inline void registerVGFConstantsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createVGFConstantsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerVGFConstantsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createVGFConstantsPass();
  });
}

//===----------------------------------------------------------------------===//
//  Registration
//===----------------------------------------------------------------------===//

inline void registerPasses() {
  registerCheckConstantSparsityPass();
  registerDenseResourceInlinerPass();
  registerModelPartitionMarkingPass();
  registerModelPartitioningPass();
  registerSerializeVGFPass();
  registerSignlessIntegerMarkingPass();
  registerTosaShapedVerificationPass();
  registerTypeNarrowingPass();
  registerVGFConstantsPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class CheckConstantSparsityPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = CheckConstantSparsityPassBase;

  CheckConstantSparsityPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  CheckConstantSparsityPassBase(const CheckConstantSparsityPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("check-constant-sparsity");
  }
  ::llvm::StringRef getArgument() const override { return "check-constant-sparsity"; }

  ::llvm::StringRef getDescription() const override { return "Detect if a TOSA constant is sparse"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CheckConstantSparsityPass");
  }
  ::llvm::StringRef getName() const override { return "CheckConstantSparsityPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CheckConstantSparsityPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class DenseResourceInlinerPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = DenseResourceInlinerPassBase;

  DenseResourceInlinerPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  DenseResourceInlinerPassBase(const DenseResourceInlinerPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("dense-resource-inliner");
  }
  ::llvm::StringRef getArgument() const override { return "dense-resource-inliner"; }

  ::llvm::StringRef getDescription() const override { return "Inline DenseResourceElementsAttr into DenseElementsAttr"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("DenseResourceInlinerPass");
  }
  ::llvm::StringRef getName() const override { return "DenseResourceInlinerPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(DenseResourceInlinerPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ModelPartitionMarkingPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ModelPartitionMarkingPassBase;

  ModelPartitionMarkingPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ModelPartitionMarkingPassBase(const ModelPartitionMarkingPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("model-partition-marking");
  }
  ::llvm::StringRef getArgument() const override { return "model-partition-marking"; }

  ::llvm::StringRef getDescription() const override { return "Mark each operation in the model with a partition attribute"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ModelPartitionMarkingPass");
  }
  ::llvm::StringRef getName() const override { return "ModelPartitionMarkingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ModelPartitionMarkingPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ModelPartitioningPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ModelPartitioningPassBase;

  ModelPartitioningPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ModelPartitioningPassBase(const ModelPartitioningPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("model-partitioning");
  }
  ::llvm::StringRef getArgument() const override { return "model-partitioning"; }

  ::llvm::StringRef getDescription() const override { return "Split the model in several sub-modules one per partition"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ModelPartitioningPass");
  }
  ::llvm::StringRef getName() const override { return "ModelPartitioningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ModelPartitioningPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> analysis{*this, "analysis", ::llvm::cl::desc("Analysis"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class SerializeVGFPassBase : public ::mlir::OperationPass<mlir::vgf::SequenceOp> {
public:
  using Base = SerializeVGFPassBase;

  SerializeVGFPassBase() : ::mlir::OperationPass<mlir::vgf::SequenceOp>(::mlir::TypeID::get<DerivedT>()) {}
  SerializeVGFPassBase(const SerializeVGFPassBase &other) : ::mlir::OperationPass<mlir::vgf::SequenceOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("serialize-vgf");
  }
  ::llvm::StringRef getArgument() const override { return "serialize-vgf"; }

  ::llvm::StringRef getDescription() const override { return "Serialize VGF MLIR to VGF binary"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SerializeVGFPass");
  }
  ::llvm::StringRef getName() const override { return "SerializeVGFPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SerializeVGFPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> emitDebugInfo{*this, "emitDebugInfo", ::llvm::cl::desc("Emit debug information"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class SignlessIntegerMarkingPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = SignlessIntegerMarkingPassBase;

  SignlessIntegerMarkingPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SignlessIntegerMarkingPassBase(const SignlessIntegerMarkingPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("signless-integer-marking");
  }
  ::llvm::StringRef getArgument() const override { return "signless-integer-marking"; }

  ::llvm::StringRef getDescription() const override { return "Mark signless integers as signed or unsigned"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SignlessIntegerMarkingPass");
  }
  ::llvm::StringRef getName() const override { return "SignlessIntegerMarkingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SignlessIntegerMarkingPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TosaShapedVerificationPassBase : public ::mlir::OperationPass<func::FuncOp> {
public:
  using Base = TosaShapedVerificationPassBase;

  TosaShapedVerificationPassBase() : ::mlir::OperationPass<func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TosaShapedVerificationPassBase(const TosaShapedVerificationPassBase &other) : ::mlir::OperationPass<func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tosa-shape-verif");
  }
  ::llvm::StringRef getArgument() const override { return "tosa-shape-verif"; }

  ::llvm::StringRef getDescription() const override { return "Optional pass that asserts no tensors in the graph are unranked or have dynamic shapes."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TosaShapedVerificationPass");
  }
  ::llvm::StringRef getName() const override { return "TosaShapedVerificationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TosaShapedVerificationPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TypeNarrowingPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TypeNarrowingPassBase;

  TypeNarrowingPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TypeNarrowingPassBase(const TypeNarrowingPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("type-narrowing");
  }
  ::llvm::StringRef getArgument() const override { return "type-narrowing"; }

  ::llvm::StringRef getDescription() const override { return "Narrow types of operations' operands/results"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TypeNarrowingPass");
  }
  ::llvm::StringRef getName() const override { return "TypeNarrowingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TypeNarrowingPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<TypeNarrowingMode> mode{*this, "mode", ::llvm::cl::desc("Type narrowing"), ::llvm::cl::init(TypeNarrowingMode::Full), ::llvm::cl::values(
               clEnumValN(TypeNarrowingMode::Full, "full", "Full type narrowing"),
               clEnumValN(TypeNarrowingMode::Partial, "partial", "Partial type narrowing"),
               clEnumValN(TypeNarrowingMode::FullPreserveIO, "full_preserve_io", "Full type narrowing with i/o types preserved")
            )};
};

template <typename DerivedT>
class VGFConstantsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = VGFConstantsPassBase;

  VGFConstantsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  VGFConstantsPassBase(const VGFConstantsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("vgf-constants");
  }
  ::llvm::StringRef getArgument() const override { return "vgf-constants"; }

  ::llvm::StringRef getDescription() const override { return "Serialize TOSA Constants to VGF"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VGFConstantsPass");
  }
  ::llvm::StringRef getName() const override { return "VGFConstantsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VGFConstantsPassBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
